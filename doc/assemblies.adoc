Assemblies
==========
:toc:

If a set of classes are your raw materials, an Assembly is the finished product,
ready to be used.

To get there, you provide Alki with your assembly definition, which acts as the instructions for
how to piece together your classes and objects. Assemblies are made up of elements, which are groups
of other elements, or various value types like services and factories.

Assembly definitions are written in a simple DSL.

Project Assemblies
------------------

Most of the time, a project will have a single assembly, so Alki makes having a single project wide
assembly especially easy.

First. in your project's `lib` directory create a ruby file for your assembly. If your assembly is
to be called `MyAssembly`, create `lib/my_assembly.rb`. If it's namespaced put it in a subdirectory
as usual (i.e. `MyModule::MyAssembly` would go in `lib/my_module/my_assembly.rb`).

Your assembly file just needs two lines:

```ruby
require 'alki'
Alki.project_assembly!
```

It will detect the project root and what class name it should create automatically.

Second, a `config` directory must be created in the project root, and in that directory an `assembly.rb`
file should be created. It should contain an `Alki do ... end` block which contains the top level
definition for your Assembly.

```ruby
Alki do
  # Assembly DSL ...
end
```

`Alki.project_assembly!` defaults can be overridden by passing in the following keyword arguments:

[horizontal]
name:: Set the name of the assembly. Should be formatted how you would put it in a `require` call
       (e.g. if `MyModule::MyAssembly` is desired, use `'my_module/my_assembly'`). Default is
       determined from the filename of the caller.

config_dir:: Set directory where assembly config files are found. Default is `<project root>/config`.

primary_config:: Sets the name of the main config file to load. Defaults to `assembly.rb`.

Manually Creating Assemblies
----------------------------

In addition to Project Assemblies, you can also create assemblies directly using `Alki.create_assembly`.
It should be called with a block that contains the assembly DSL. It will return a Module object that can
be used directly or assigned to a constant.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :msg, "hello world"
  func :run do
    puts msg
  end
end

assembly.new.run

# output: hello world
```

Using Assemblies
----------------

Assemblies have a `new` method used to create new assembly instances (like a normal class). Once an
instance is created, anything in the assembly is accessible by drilling down into groups.

Given an assembly like this:

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :log_io, STDERR
  group :util do
    service :logger do
      require 'logger'
      Logger.new log_io
    end
  end
end
```

One can use the logger service like so:

```ruby
instance = assembly.new
instance.util.logger.info "test"

# output: I, [<timestamp>] INFO -- : test
```

### Overrides

Assembly overrides provide a way to configure or customize an Assembly when
constructing an instance.

For example, using the assembly created above, one might want to change the IO object logged to.

The simplist way to do this is to provide a hash which will override values in the assembly (as if the `set`
command was called in the DSL):

```ruby
require 'stringio'
io = StringIO.new
instance = assembly.new log_io: io
instance.util.logger.info "test"
puts(io.string.match(/INFO -- : test/) != nil)

# output: true
```

The limitiation of this is that it can only override basic values. To override more complex elements
a block can be given to `new` allowing the full assembly DSL.

```ruby
require 'alki'
class MyLogger
  def initialize(io)
    @io = io
  end
  def info(msg)
    @io.puts "INFO #{msg}"
  end
end

instance = assembly.new do
  group :util do
    service :logger do
      MyLogger.new original.log_io
    end
  end
end
instance.util.logger.info "test"

# output: INFO test
```

One thing of note is that elements from the assembly are accessible in overrides via the `original`
method, as seen above. This can also be used to access the original versions of elements that have
been overriden.