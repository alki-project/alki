Assembly DSL
============
:toc:

Building Assemblies is done via a small DSL

Groups (group)
--------------

Groups are the basic way of organizing the elements of your Assembly. Creating elements at the top
level of an Assembly will place them in a root group, but subgroups are easily created via the `group`
command.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  group :sub_group do
    set :val, "hello world"
  end
end
puts assembly.new.sub_group.val

#output: hello world
```

Scoping is also done by group, so that an element will be found by searching through parent groups.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :val, "one"
  func :print do
    puts val
  end

  group :g1 do
    set :val, "two"

    group :g2 do
      func :print do
        puts val
      end
    end

  end
end

assembly.new.print

#output: one

assembly.new.g1.g2.print

#output: two
```

=== Loading groups (load)

Groups can also be loaded from other config files via the `load` command.

.config/settings.rb
```ruby
Alki do
  set :val, "hello"
end
```

.main code
```ruby
require 'alki'
assembly = Alki.create_assembly config_dir: 'config' do
  load :settings
  func :print do
     puts settings.val
  end
end
assembly.new.print

# output: hello
```


Values
------

Values are how you add functionality to your Assembly. There are different types of values, but they
all share a number of common features.

### On-Demand

Values are only built when referenced, on demand. This means even if you have a very large assembly
only the things you actually use in a given run will be created, or often even `require`-d. It also
means that all values will automatically be built in the correct order to satisfy dependencies.

### Scope

When providing a block for a value, the block will be executed in a special context with some
additional helper methods.

The most important methods available are other elements that are "in scope". For example, a value can
reference a sibling element in the same group, or any value in any ancestor group. The order that
elements are defined does not effect what is in scope. All other elements are out of scope, but can
usually still be referenced by finding an ancestor group that 'is' in scope, and then drilling down
from there.

```ruby
require 'alki'
assembly = Alki.create_assembly config_dir: 'config' do
  set :val1, "1"
  group :main do
    group :sub_group do
      set :val2, "2"
    end

    set :values do
      [
        val1, # OK
      # val2, # ERROR
        sub_group.val2, # OK
        val3, # OK
      # val4, # ERROR
        other_group.val4, #OK
      ].join('')
    end

    set :val3, "3"
  end

  group :other_group do
    set :val4, "4"
  end

end
puts assembly.new.main.values

#output: 1234
```

### Helpers

In addition to elements in scope, there are some helper methods that are always available in value
blocks.

[horizontal]

assembly:: This will return the root group of the assembly the element is defined in.

root:: This will return the root group of the 'top most' assembly being run. If only a single
assembly is being run, this will be the same as `assembly` but if the element being run is in
an assembly that has been mounted into another assembly, they will differ.

lookup(path):: This can be used to reference an element by a string path (using periods (`.`) to
drill down into groups). If called directly it will lookup using the local scope. It is also available
as a method on all groups, so `assembly.lookup(path)` would lookup an element starting from the root
of the assembly.

lazy(path):: This works the same as `lookup`, but with an important difference: Instead of doing the
lookup immediately, it will instead return a "proxy" object, which will do the lookup the first time
a method is called on the proxy object, and then delegate all method calls to the actual element. This
can be used to handle circular references in services.

Value Types
-----------

There are four types of elements loosely categorized as "values".

### Basic Values (set)

The simplest type of values are ones created via the `set` command. There are two forms of `set`.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  # This form takes the value as the second argument
  set :val1, "hello"

  # INVALID! Value may not be a reference to another element
  # set :val2, val1

  # This form takes the value as a block.
  # Block is run once and result cached.
  # Allows referencing other elements
  set :val2 do
    val1
  end
end
puts assembly.new.val2

#output: hello
```

### Functions (func)

Simple callable values can be created with the `func` command. These can take arguments, are run
each time they are referenced, and can access other elements.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :greeting, "Hello %s!"

  func :greet do |name|
    puts(greeting % [name])
  end
end
puts assembly.new.greet "Matt"

#output: Hello Matt!
```

### Services (service)

Services are the key element Assemblies are typically made up of. Like the block form of `set`,
`service` takes a name and block, which will be evaluated once on-demand and the result cached.
Whereas `set` is a lightweight element for simple values, `service` provides more functionality.

Commonly a service will require the file that defines a class, and then constructs an instance of
that class.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  service :logger do
    require 'logger'
    Logger.new STDOUT
  end
end
assembly.new.logger << "hello\n"

#output: hello
```

### Factories (factory)

Factories are a mix between services and funcs. Like services, they take a block which is evaluated
once. Unlike services though, that block must return a callable "builder" (like a Proc).

If a factory is referenced as a service (i.e. no arguments) it returns a factory object
that responds to either `#call` or `#new` and will call the builder in turn.

If a factory is instead referenced like a method (i.e. with arguments) it will
call the builder directly.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  factory :logger do
    require 'logger'
    -> (io) { Logger.new io }
  end

  service :main_logger do
    logger STDOUT
    # -or-
    logger.call STDOUT
  end
end
assembly.new.main_logger << "hello\n"

#output: hello
```


## Mounting Assemblies (mount)

Other assemblies can be mounted into your Assembly using the `mount` command.

The first argument is what the element should be named in the parent assembly.
The optional second argument is the assembly to be mounted.
This can either be the assembly module,
or be a "require" string (relative path but no `.rb`).
It defaults to the element name.
If a string, Alki will attempt to `require` it, and then look for a matching constant.


```ruby
require 'alki'

other_assembly = Alki.create_assembly do
  set :val, "one"

  # This is invalid as there is no such element as 'val2'
  set :invalid_val2 do
    val2
  end

  # Normally, this would also be invalid, but if mounted
  # in an assembly that has a 'val2' element, this works.
  set :root_val2 do
    root.val2
  end
end

assembly = Alki.create_assembly do
  set :val2, "two"
  mount :other, other_assembly
end
instance = assembly.new
puts instance.other.val
#output: one

# Even though val2 exists in MainAssembly, it is not directly accessibly to elements
# within OtherAssembly
begin
  puts instance.other.invalid_val2
rescue => e
  puts e
end
# output: undefined local variable or method 'val2'

# This works, because root returns the root assembly, which has a 'val2' element
puts instance.other.root_val2
#output: two
```

In addition, `assembly` takes an optional third hash argument or a block which can be used to set
overrides in the same way `::new` does for assemblies. Elements from the parent assembly are
automatically in scope for overrides.

```ruby
require 'alki'
other_assembly = Alki.create_assembly do
  set :msg, nil
  func :print do
    puts msg
  end
end

assembly = Alki.create_assembly do
  set :val, "hello"
  mount :other, other_assembly do
    set :msg do
      val
    end
  end
end
assembly.new.other.print

#output: hello
```

### Optional mounts (try_mount)

Sometimes a library might not always be present. For example, using Bundler
for development only gems. In that case `try_mount` can be used instead of
`mount`. If the assembly library can't be found, the mount will simply be
ignore.

## Overlays and Tags

Overlays are a way to transparently wrap services. They work by taking the
name of a service or a group, in which case they are applied to all services in that group,
along with the name of an element to be used as the overlay, plus some optional arguments.

When the named service is built, the overlay element will be called (with `.call`), with
the built service object and the optional arguments, and it's result will be what's
returned.

Factories work well as overlay elements.

```ruby
require 'alki'

assembly = Alki.create_assembly do
  overlay :greeting, :exclaim, 3

  service :greeting do
    'Hello World'
  end

  factory :exclaim do
    -> (string,count) do
      string + ('!' * count)
    end
  end
end

puts assembly.new.greeting

#output: Hello World!!!
```

### Tags (tag)

Tags are way of adding metadata to your elements. They can either be just a name, or
optionally carry a value

```ruby
require 'alki'

assembly = Alki.create_assembly do
  tag :tag1, with_value: 123
  service :tagged do
    meta[:tags]
  end
end

puts assembly.new.tagged

#output: {:with_value=>123, :tag1=>true}
```

Tags can be applied to groups to tag everything within that group

```ruby
require 'alki'

assembly = Alki.create_assembly do
  tag :tag1
  group :grp do
    tag :tag2
    service :tagged do
      meta[:tags]
    end
  end
end

puts assembly.new.grp.tagged

#output: {:tag1=>true, :tag2=>true}
```

#### Overlaying tags (overlay_tag)

Instead of overlaying services directly, it's often useful to overlay all services
with a given tag.

```ruby
require 'alki'

assembly = Alki.create_assembly do
  overlay_tag :exclaimed, :exclaim, 3

  tag :exclaimed
  service :greeting do
    'Hello World'
  end

  factory :exclaim do
    -> (string,count) do
      string + ('!' * count)
    end
  end
end

puts assembly.new.greeting

#output: Hello World!!!
```

Factories can access the tags of the services their being called from, allowing you
to customize the build based on what tags are present

```ruby
require 'alki'

assembly = Alki.create_assembly do
  overlay_tag :process, :process_string

  tag :process, exclaim: 3
  service :greeting do
    'Hello World'
  end

  factory :process_string do
    -> (string) do
      if exclaim = meta[:tags][:exclaim]
        string = string + ('!' * exclaim)
      end
      string
    end
  end
end

puts assembly.new.greeting

#output: Hello World!!!
```

Finally, tag overlays work even across assembly mounts, allowing overlays to
be defined in a library, and then applied by tagging services.

```ruby
require 'alki'

string_processor = Alki.create_assembly do
  overlay_tag :process, :process_string

  factory :process_string do
    -> (string) do
      if exclaim = meta[:tags][:exclaim]
        string = string + ('!' * exclaim)
      end
      string
    end
  end
end

assembly = Alki.create_assembly do
  mount :string_processor, string_processor

  tag :process, exclaim: 3
  service :greeting do
    'Hello World'
  end
end

puts assembly.new.greeting

#output: Hello World!!!
```
