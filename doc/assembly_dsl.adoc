Assembly DSL
============
:toc:

Building Assemblies is done via a DSL that makes putting together the pieces of your project easy.

Groups (group)
--------------

Groups are the basic way of organizing the elements of your Assembly. Creating elements at the top
level of an Assembly will place them in a root group, but subgroups are easily created via the `group`
command.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  group :sub_group do
    set :val, "hello world"
  end
end
puts assembly.new.sub_group.val

#output: hello world
```

Scoping is also done by group, so that an element will be found by searching through parent groups until
it is found.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :val, "one"
  func :print do
    puts val
  end

  group :g1 do
    set :val, "two"

    group :g2 do
      func :print do
        puts val
      end
    end

  end
end

assembly.new.print

#output: one

assembly.new.g1.g2.print

#output: two
```

=== Loading groups (load)

Groups can also be loaded from other config files via the `load` command.

.config/settings.rb
```ruby
Alki do
  set :val, "hello"
end
```

.main code
```ruby
require 'alki'
assembly = Alki.create_assembly config_dir: 'config' do
  load :settings
  func :print do
     puts settings.val
  end
end
assembly.new.print

# output: hello
```


Values
------

Values are how you add functionality to your Assembly. There are different types of values, but they
all share a number of common features.

### On-Demand

Values are only built when referenced, on demand. This means even if you have a very large assembly
only the things you actually use in a given run will be created, or often even `require`-d. It also
means that all values will automatically be built in the correct order to satisfy dependencies.

### Scope

When providing a block for a value, the block will be executed in a special context with some
additional helper methods.

The most important methods available are other elements that are "in scope". For example, a value can
reference a sibling element in the same group, or any value in any ancestor group. The order that
elements are defined does not effect what is in scope. All other elements are out of scope, but can
usually still be referenced by finding an ancestor group that 'is' in scope, and then drilling down
from there.

```ruby
require 'alki'
assembly = Alki.create_assembly config_dir: 'config' do
  set :val1, "1"
  group :main do
    group :sub_group do
      set :val2, "2"
    end

    set :values do
      [
        val1, # OK
      # val2, # ERROR
        sub_group.val2, # OK
        val3, # OK
      # val4, # ERROR
        other_group.val4, #OK
      ].join('')
    end

    set :val3, "3"
  end

  group :other_group do
    set :val4, "4"
  end

end
puts assembly.new.main.values

#output: 1234
```

### Helpers

In addition to elements in scope, there are some helper methods that are always available in value
blocks.

[horizontal]

assembly:: This will return the root group of the assembly the element is defined in.

root:: This will return the root group of the 'top most' assembly being run. If only a single
assembly is being run, this will be the same as `assembly` but if the element being run is in
an assembly that has been mounted into another assembly, they will differ.

lookup(path):: This can be used to reference an element by a string path (using periods (`.`) to
drill down into groups). If called directly it will lookup using the local scope. It is also available
as a method on all groups, so `assembly.lookup(path)` would lookup an element starting from the root
of the assembly.

lazy(path):: This works the same as `lookup`, but with an important difference: Instead of doing the
lookup immediately, it will instead return a "proxy" object, which will do the lookup the first time
a method is called on the proxy object, and then delegate all method calls to the actual element. This
can be used to handle circular references in services.

Value Types
-----------

There are four types of elements loosely categorized as "values".

### Basic Values (set)

The simplest type of values are ones created via the `set` command. There are two forms of `set`.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  # This form takes the value as the second argument
  set :val1, "hello"

  # INVALID! Value may not be a reference to another element
  # set :val2, val1

  # This form takes the value as a block.
  # Block is run once and result cached.
  # Allows referencing other elements
  set :val2 do
    val1
  end
end
puts assembly.new.val2

#output: hello
```

### Functions (func)

Simple callable values can be created with the `func` command. These can take arguments, are run
each time they are referenced, and can access other elements.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :greeting, "Hello %s!"

  func :greet do |name|
    puts(greeting % [name])
  end
end
puts assembly.new.greet "Matt"

#output: Hello Matt!
```

### Services (service)

Services are the key element Assemblies are typically made up of. Like the block form of `set`,
`service` takes a name and block, which will be evaluated once on-demand and the result cached.
One difference between the block form of `set` and `service` is that services are affected
by overlays, whereas basic values are not.

Commonly a service will require the file that defines a class, and then constructs an instance of
that class.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  service :logger do
    require 'logger'
    Logger.new STDOUT
  end
end
assembly.new.logger << "hello"

#output: hello
```

### Factories (factory)

Factories are a mix between services and funcs. Like services, they take a block which is evaluated
once. Unlike services though, that block must return a callable object (like a Proc). This object
is then called directly when the factory is referenced. This allows you to require files or construct
a factory object once but still run code on every reference.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  factory :logger do
    require 'logger'
    -> (io) { Logger.new io }
  end

  service :main_logger do
    logger STDOUT
  end
end
assembly.new.main_logger << "hello"

#output: hello
```

## Overlays (overlay)

Overlays are a way to intercept and transform calls made to all services in a given group or it's
sub-groups.

Overlays are often most useful in groups where all services adhere to a common interface, and overlays
can be used to perform aspect oriented programming like logging, validation, or access controls.


## Assemblies (assembly)

Other assemblies can be mounted into your Assembly using the `assembly` command.

The first argument is what the element should be named in the parent assembly. The optional second argument
is the name of the assembly to be mounted. This should be formatted like a require string (relative path but
no `.rb`) and will default to the value of the first argument. If a classified version of that name
can't be found, Alki will attempt to `require` it, and then look for it again.

```ruby
require 'alki'

# Creates OtherAssembly
Alki.create_assembly name: 'other_assembly' do
  set :val, "one"

  # This is invalid as there is no such element as 'val2'
  set :invalid_val2 do
    val2
  end

  # Normally, this would also be invalid, but if mounted
  # in an assembly that has a 'val2' element, this works.
  set :root_val2 do
    root.val2
  end
end

Alki.create_assembly name: 'main_assembly' do
  set :val2, "two"
  # Mounts OtherAssembly as 'other'
  assembly :other, 'other_assembly'
end
instance = MainAssembly.new
puts instance.other.val
#output: one

# Even though val2 exists in MainAssembly, it is not directly accessibly to elements
# within OtherAssembly
begin
  puts instance.other.invalid_val2
rescue => e
  puts e
end
# output: undefined local variable or method 'val2'

# This works, because root returns the root assembly, which has a 'val2' element
puts instance.other.root_val2
#output: two
```

In addition, `assembly` takes an optional third hash argument or a block which can be used to set
overrides in the same way `::new` does for assemblies. Elements from the parent assembly are
automatically in scope for overrides.

```ruby
require 'alki'
Alki.create_assembly name: 'other_assembly' do
  set :msg, nil
  func :print do
    puts msg
  end
end

Alki.create_assembly name: 'main_assembly' do
  set :val, "hello"
  assembly :other, 'other_assembly' do
    set :msg do
      val
    end
  end
end
MainAssembly.new.other.print

#output: hello
```
