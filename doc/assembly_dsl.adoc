Assembly DSL
===========

Building Assemblies is done via a DSL that makes putting together the pieces of your project easy.

Groups
------

Groups are the basic way of organizing the elements of your Assembly. Creating elements at the top
level of an Assembly will place them in a root group, but subgroups are easily created via the `group`
command.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  group :sub_group do
    set :val, "hello world"
  end
end
puts assembly.new.sub_group.val

#output: hello world
```

Scoping is also done by group, so that an element will be found by searching through parent groups until
it is found.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :val, "one"
  func :print do
    puts val
  end

  group :g1 do
    set :val, "two"

    group :g2 do
      func :print do
        puts val
      end
    end

  end
end

assembly.new.print

#output: one

assembly.new.g1.g2.print

#output: two
```

=== Loading groups

Groups can also be loaded from other config files via the `load` command.

.config/settings.rb
```ruby
Alki do
  set :val, "hello"
end
```

.main code
```ruby
require 'alki'
assembly = Alki.create_assembly config_dir: 'config' do
  load :settings
  func :print do
     puts settings.val
  end
end
assembly.new.print

# output: hello
```


Values
------

There are four types of elements loosely categorized as "values".

### Basic Values (set)

The simplest type of values are ones created via the `set` command. There are two forms of `set`.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  # This form takes the value as the second argument
  set :val1, "hello"

  # INVALID! Value may not be a reference to another element
  # set :val2, val1

  # This form takes the value as a block.
  # Block is run once and result cached.
  # Allows referencing other elements
  set :val2 do
    val1
  end
end
puts assembly.new.val2

#output: hello
```

### Functions (func)

Simple callable values can be created with the `func` command. These can take arguments, are run
each time they are referenced, and can access other elements.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  set :greeting, "Hello %s!"

  func :greet do |name|
    puts(greeting % [name])
  end
end
puts assembly.new.greet "Matt"

#output: Hello Matt!
```

### Services (service)

Services are the key element Assemblies are typically made up of. Like the block form of `set`,
`service` takes a name and block, which will be evaluated once on-demand and the result cached.
One difference between the block form of `set` and `service` is that services are affected
by overlays, whereas basic values are not.

Commonly a service will require the file that defines a class, and then constructs an instance of
that class.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  service :logger do
    require 'logger'
    Logger.new STDOUT
  end
end
assembly.new.logger << "hello"

#output: hello
```

### Factories (factory)

Factories are a mix between services and funcs. Like services, they take a block which is evaluated
once. Unlike services though, that block must return a callable object (like a Proc). This object
is then called directly when the factory is referenced. This allows you to require files or construct
a factory object once but still run code on every reference.

```ruby
require 'alki'
assembly = Alki.create_assembly do
  factory :logger do
    require 'logger'
    -> (io) { Logger.new io }
  end

  service :main_logger do
    logger STDOUT
  end
end
assembly.new.main_logger << "hello"

#output: hello
```

## Overlays (overlay)

Overlays are a way to intercept and transform calls made to all services in a given group or it's
sub-groups.

Overlays are often most useful in groups where all services adhere to a common interface, and overlays
can be used to perform aspect oriented programming like logging, validation, or access controls.


## Assemblies (assembly)

Other assemblies can be mounted into your Assembly using the `assembly` command.

The first argument is what the element should be named in the parent assembly. The optional second argument
is the name of the assembly to be mounted. This should be formatted like a require string (relative path but
no `.rb`) and will default to the value of the first argument. If a classified version of that name
can't be found, Alki will attempt to `require` it, and then look for it again.

```ruby
require 'alki'

# Creates OtherAssembly
Alki.create_assembly name: 'other_assembly' do
  set :val, "one"

  # This is invalid as there is no such element as 'val2'
  set :invalid_val2 do
    val2
  end

  # Normally, this would also be invalid, but if mounted
  # in an assembly that has a 'val2' element, this works.
  set :root_val2 do
    root.val2
  end
end

Alki.create_assembly name: 'main_assembly' do
  set :val2, "two"
  # Mounts OtherAssembly as 'other'
  assembly :other, 'other_assembly'
end
instance = MainAssembly.new
puts instance.other.val
#output: one

# Even though val2 exists in MainAssembly, it is not directly accessibly to elements
# within OtherAssembly
begin
  puts instance.other.invalid_val2
rescue => e
  puts e
end
# output: undefined local variable or method 'val2'

# This works, because root returns the root assembly, which has a 'val2' element
puts instance.other.root_val2
#output: two
```

In addition, `assembly` takes an optional third hash argument or a block which can be used to set
overrides in the same way `::new` does for assemblies. Elements from the parent assembly are
automatically in scope for overrides.

```ruby
require 'alki'
Alki.create_assembly name: 'other_assembly' do
  set :msg, nil
  func :print do
    puts msg
  end
end

Alki.create_assembly name: 'main_assembly' do
  set :val, "hello"
  assembly :other, 'other_assembly' do
    set :msg do
      val
    end
  end
end
MainAssembly.new.other.print

#output: hello
```
